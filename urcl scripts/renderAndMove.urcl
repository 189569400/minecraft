bits == 8
minreg 7
minheap 4
minstack 2

//constants
    //general constants
        @define BLOCKSIZE 16
        @define PLAYERWIDTH 9 //technically it's 10, but 9 makes calculations easier
        @define PLAYERHEIGHT 28 //technically it's 29, but 28 makes calculations easier
        @define HALFPLAYERWIDTH 5
        @define PLAYERCAMHEIGHT 24
        @define PLAYERWIDTHFULL 10
    //block IDs
        @define BLOCK_AIR 0x0
        @define BLOCK_grass 0x1
        @define BLOCK_DIRT 0x2
        @define BLOCK_STONE 0x3
        @define BLOCK_COBBLE 0x4
        @define BLOCK_LOG 0x5
        @define BLOCK_LEAVES 0x6
        @define BLOCK_PLANK 0x7
        @define BLOCK_COALORE 0x8
        @define BLOCK_IRONORE 0x9
        @define BLOCK_SAND 0xA
        @define BLOCK_GLASS 0xB
        @define BLOCK_SAPLING 0xC
        @define BLOCK_TABLE 0xD
        @define BLOCK_FURNACE 0xE
        @define BLOCK_CHEST 0xF
    //item IDs
        @define ITEM_AIR 0x00
        @define ITEM_STICK 0x10
        @define ITEM_DIRT 0x20
        @define ITEM_STONE 0x30
        @define ITEM_COBBLE 0x40
        @define ITEM_LOG 0x50
        @define ITEM_LEAVES 0x60
        @define ITEM_PLANK 0x70
        @define ITEM_COAL 0x80
        @define ITEM_IRONORE 0x90
        @define ITEM_SAND 0xA0
        @define ITEM_GLASS 0xB0
        @define ITEM_SAPLING 0xC0
        @define ITEM_IRONINGOT 0xD0
        @define ITEM_APPLE 0xE0
        @define ITEM_NONSTACKABLE 0xF0

        @define ITEM_WOODPICKAXE 0xF0
        @define ITEM_WOODAXE 0xF1
        @define ITEM_WOODSHOVEL 0xF2
        @define ITEM_WOODSWORD 0xF3
        @define ITEM_STONEPICKAXE 0xF4
        @define ITEM_STONEAXE 0xF5
        @define ITEM_STONESHOVEL 0xF6
        @define ITEM_STONESWORD 0xF7
        @define ITEM_IRONPICKAXE 0xF8
        @define ITEM_IRONAXE 0xF9
        @define ITEM_IRONSHOVEL 0xFA
        @define ITEM_IRONSWORD 0xFB
        @define ITEM_SHEARS 0xFC
        @define ITEM_TABLE 0xFD
        @define ITEM_FURNACE 0xFE
        @define ITEM_CHEST 0xFF

//memory locations
    @define x m0 //replace with 0x00 if 'm0' not supported in translator
    @define y m1
    @define z m2
    @define rot m3

//initial values
str x 0x10
str y 0x20
str z 0x10
str rot 0x00



.loop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        //handle miscellaneous inputs
            in r0 %playerinput //is open/close inventory pressed?
            in r0 %playerinput //inventory movement
            in r0 %playerinput //is break pressed?
            in r0 %playerinput //is place pressed?

            in r0 %playerinput //is crouch pressed?

        //handle rotation inputs
            in r1 %playerinput //rotation

            lod r2 rot
            addv r1 r1 r2
            str rot r1

        //handle movement inputs
            in r1 %playerinput //forward movement

            in r2 %amogus_sinyaw
            neg r3 r2
            smlt446 r4 r1 r3 //r3 = velX

            in r3 %amogus_cosyaw
            smlt446 r5 r1 r3 //r4 = velZ

            in r1 %playerinput //strafe movement

            smlt446 r6 r1 r2
            add r5 r5 r6 //r5 = velZ

            smlt446 r6 r1 r3
            add r4 r4 r6 //r4 = velX

            psh r5 //stack 0 = velZ
            psh r4 //stack 1 = velX
        
        //move and collide in X axis
            //current useful variables
                //r4 = velX
                //top of stack = velX
            lod r2 x
            add r1 r2 r4 //r1 = minX
            str x r1
            brn ~+3 r4 //if velocity negative, use -x side of player to collide. Otherwise use +x side
                add r1 r1 PLAYERWIDTH //r1 = maxX
                add r2 r2 PLAYERWIDTH //r2 - maxPrevX
            bsr r2 r2 4 //floor(prevX)
            bsr r3 r1 4 //floor(currentX)
            bre .collideXEndCleanup r2 r3 //if block X doesn't change with move, don't check X collision
            and r1 r1 0xf0 //floor(x) << 4
            lod r2 y //r2 = minY
            add r3 r2 PLAYERHEIGHT //r3 = maxY
            bsr r2 r2 4 //r2 = floor(minY)
            bsr r3 r3 4 //r3 = floor(maxY)
            lod r4 z //r4 = minZ
            add r5 r4 PLAYERWIDTH //r5 = maxZ
            bsr r4 r4 4 //floor(minZ)
            bsr r5 r5 4 //floor(maxZ)
            .collideXLoopY
                mov r6 r4
                or r7 r1 r2 //combine X and Y to one register to send to %blockram
                out %blockram_xy r7
                .collideXLoopZ
                    out %blockram_z r6
                    in r7 %blockram_id
                    brz .collideXNoCollision r7 //if air, do not collide with this block
                    bre .collideXNoCollision r7 BLOCK_SAPLING //if sapling, do not collide with this block
                    //collision detected
                        pop r2 //r2 = velX
                        brp ~+3 r2 //velocity is negative, resolve collision towards +x
                            add r1 r1 BLOCKSIZE
                            jmp ~+2
                        //velocity is positive, resolve collision towards -x
                            sub r1 r1 PLAYERWIDTHFULL
                        str x r1
                        jmp .collideXEnd //once a single collision is found, we don't need to check for any more
                        //cleanup already done
                    .collideXNoCollision
                    inc r6 r6
                ble .collideXLoopZ r6 r5
                inc r2 r2
                and r1 r1 0xf0 //separate X and Y
            ble .collideXLoopY r2 r3
            .collideXEndCleanup
                pop r0 //remove velX from stack if it isn't already removed
        .collideXEnd

        //move and collide in Z axis
            //current useful variables:
                //top of stack = velZ
            lod r2 z
            lod r4 sp //velZ
            add r1 r2 r4 //r1 = minZ
            str z r1
            brn ~+3 r4 //if velocity negative, use -z side of player to collide. Otherwise use +z side
                add r1 r1 PLAYERWIDTH //r1 = maxZ
                add r2 r2 PLAYERWIDTH //r2 = maxPrevZ
            bsr r2 r2 4 //floor(prevZ)
            bsr r3 r1 4 //floor(currentZ)
            bre .collideZEndCleanup r2 r3 //if block Z doesn't change with move, don't check z collisions
            bsr r1 r1 4 //floor(z)
            lod r2 y
            add r3 r2 PLAYERHEIGHT
            bsr r2 r2 4
            bsr r3 r3 4
            lod r4 x
            add r5 r4 PLAYERWIDTH
            and r4 r4 0xf0
            and r5 r5 0xf0
            out %blockram_z r1
            .collideZLoopY
                mov r6 r4
                .collideZLoopX
                    or r7 r6 r2 //combine X and Y together to send to %blockram
                    out %blockram_xy r7
                    in r7 %blockram_id
                    brz .collideZNoCollision r7
                    bre .collideZNoCollision r7 BLOCK_SAPLING
                    //collision detected
                        pop r2 //velZ
                        bsl r1 r1 4
                        brp ~+3 r2 //velocity is negative, resolve collision towards +z
                            add r1 r1 BLOCKSIZE
                            jmp ~+2
                        //velocity is positive, resolve collision towards -z
                            sub r1 r1 PLAYERWIDTHFULL
                        str z r1
                        jmp .collideZEnd
                    .collideZNoCollision
                    add r6 r6 BLOCKSIZE
                ble .collideZLoopX r6 r5
                inc r2 r2
            ble .collideZLoopY r2 r3
            .collideZEndCleanup
                pop r0 //remove velZ from stack if it isn't alreadt removed
        .collideZEnd

        //TODO: handle jumping and move and collide in Y
            in r0 %playerinput //is jump pressed?
            //# in r1 %playerinput //is jump pressed
            //# brz ~+4 r1
            //#     mov r3 0 //Y velocity if no jump
            //#     lod r1 y
            //#     and r1 r1 0x0F
            //#     brz ~+2 r1 //check if on ground
            //#         imm r3 17 //Y velocity upon jump.
        
        in r0 %playerinput //is drop item pressed?

    //do rendering stuff
        //send camera data to AMOGUS
            lod r1 rot
            out %amogus_camrot r1
            lod r1 x
            add r1 r1 HALFPLAYERWIDTH //move from corner of player to middle
            out %amogus_camx r1
            lod r1 y
            add r1 r1 PLAYERCAMHEIGHT //don't place camera at feet
            out %amogus_camy r1
            lod r1 z
            add r1 r1 HALFPLAYERWIDTH //move from corner of player to middle
            out %amogus_camz r1
        
        in r0 %meshgen_renderscene

        in r0 %amogus_drawtoscreen
        in r0 %screen_buffer

        in r0 %amogus_clearbuffer

    out %wait 125
    in r0 %wait
jmp .loop
