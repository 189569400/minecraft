bits == 8
minreg 7
minheap 29
minstack 23

//constants
    //size constants
        @define BLOCKSIZE 16
        @define PLAYERWIDTH 9 //technically it's 10, but 9 makes calculations easier
        @define PLAYERHEIGHT 28 //technically it's 29, but 28 makes calculations easier
        @define PLAYERHALFWIDTH 5
        @define PLAYERCAMHEIGHT 24
        @define PLAYERCROUCHCAMHEIGHT 22
        @define MIDDLEOFVOID 0b1100_0000
        @define BLOCKMIDDLEOFVOID 0b1100
    //gameplay constants
        @define GRAVITY 15 //the downwards change in velocity per frame
        @define JUMPSTRENGTH 17 //the initial vertical velocity of a jump
        @define SPEEDFACTOR 0b01_000000 //scales the speed of the characters movement. A value of 1 results in a speed of 4 while crouching, 8 while walking, and 12 while sprinting. In 0bSX.XXXXXX format
        @define RAYCASTMAXLENGTH 0b0100_0000
    //block IDs
        @define BLOCK_AIR 0x0
        @define BLOCK_grass 0x1
        @define BLOCK_DIRT 0x2
        @define BLOCK_STONE 0x3
        @define BLOCK_COBBLE 0x4
        @define BLOCK_LOG 0x5
        @define BLOCK_LEAVES 0x6
        @define BLOCK_PLANK 0x7
        @define BLOCK_COALORE 0x8
        @define BLOCK_IRONORE 0x9
        @define BLOCK_SAND 0xA
        @define BLOCK_GLASS 0xB
        @define BLOCK_SAPLING 0xC
        @define BLOCK_TABLE 0xD
        @define BLOCK_FURNACE 0xE
        @define BLOCK_CHEST 0xF
    //item IDs
        @define ITEM_AIR 0x00
        @define ITEM_STICK 0x10
        @define ITEM_DIRT 0x20
        @define ITEM_STONE 0x30
        @define ITEM_COBBLE 0x40
        @define ITEM_LOG 0x50
        @define ITEM_LEAVES 0x60
        @define ITEM_PLANK 0x70
        @define ITEM_COAL 0x80
        @define ITEM_IRONORE 0x90
        @define ITEM_SAND 0xA0
        @define ITEM_GLASS 0xB0
        @define ITEM_SAPLING 0xC0
        @define ITEM_IRONINGOT 0xD0
        @define ITEM_APPLE 0xE0
        @define ITEM_NONSTACKABLE 0xF0
    //nonstackable IDs
        @define ITEM_WOODPICKAXE 0xF0
        @define ITEM_WOODAXE 0xF1
        @define ITEM_WOODSHOVEL 0xF2
        @define ITEM_WOODSWORD 0xF3
        @define ITEM_STONEPICKAXE 0xF4
        @define ITEM_STONEAXE 0xF5
        @define ITEM_STONESHOVEL 0xF6
        @define ITEM_STONESWORD 0xF7
        @define ITEM_IRONPICKAXE 0xF8
        @define ITEM_IRONAXE 0xF9
        @define ITEM_IRONSHOVEL 0xFA
        @define ITEM_IRONSWORD 0xFB
        @define ITEM_SHEARS 0xFC
        @define ITEM_TABLE 0xFD
        @define ITEM_FURNACE 0xFE
        @define ITEM_CHEST 0xFF

//memory locations
//OPTIM: it might be worth placing some of these at the base of the stack instead of the heap to reduce cache misses
    @define x m0 //replace with 0x00 if 'm0' not supported in translator
    @define y m1
    @define z m2
    @define rot m3
    @define onGround m4
    @define velY m5
    @define needReRender m6
    @define crouching m7
    @define prevX m8
    @define prevY m9
    @define prevZ m10
    @define targetedBlockXZ m11
    @define targetedBlockY m12
    @define inventory m13 //takes up 15 cells (m13-m27)
    @define hotbarSlot m28

//initial values
    str x 0x10
    str y 0x20
    str z 0x10
    str rot 0x00
    str onGround @max
    str velY 0
    str needReRender @max
    str crouching 0
    str prevX 0
    str prevY 0
    str prevZ 0
    str targetedBlockXZ 0xff
    str targetedBlockY 0xff

.mainLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        //handle miscellaneous inputs
            in r0 %playerinput //is open/close inventory pressed?
            in r0 %playerinput //inventory movement
        
        //handle break/place
            cal .rayCast
                //r1: x, z pos of space before first found block
                //r2: y pos of space before first found block
                //r3: x, z pos of first found block
                //r4: y pos of first found block
                //r5: id of first found block (returns air if nothing found, bedrock will return -1)
                //r6: length of raycast (returns -1 if nothing found)
            in r7 %playerinput //is break pressed?
            lod r6 hotbarSlot
            add r6 inventory r6 //r6 = pointer towards item in hand
            lod r6 r6 //r6 = item in hand
            brz .noRayCastHit r5
            brz .endBreakBlock r7
                brn .endBreakBlock r5 //if bedrock, can't break block
                //TODO: use the item in hand
                //TODO: add animation/block breaking delay
                bsr r7 r3 4
                out %blockram_x r7
                and r7 r3 0x0f
                out %blockram_z r7
                out %blockram_y r4
                //TODO: drop item entity
                out %blockram_id 0 //replace targeted block with air
                //TODO: check if block above this block is sand, if so, make it fall
                str needReRender @max
                jmp .endBreakAndPlace
            .endBreakBlock
            in r7 %playerinput //is place pressed?
            brz .endBreakAndPlace r7
                lod r7 crouching
                //TODO: check if targeted block is usable, if so, use it
                //TODO: check if item in hand is usable without target, if so, jump to .useNonPlaceable
                //TODO: check if item in hand is placeable, if so place it
                bsr r7 r1 4
                out %blockram_x r7
                and r7 r1 0x0f
                out %blockram_z r7
                out %blockram_y r2
                out %blockram_id BLOCK_GRASS //TEMP: replace grass with whatever is currently held
            jmp .endBreakAndPlace
            .noRayCastHit
                in r7 %playerinput //is place pressed?
                //TODO: check if item in hand is usable without a target, if not, skip to .endBreakAndPlace
            .useNonPlaceable
                //TODO: use nonplaceable items
        .endBreakAndPlace

        //handle crouching inputs
            in r1 %playerinput //is crouch pressed?
            lod r2 crouching
            bre ~+3 r1 r2 //if crouching status changed:
                str crouching r1
                str needReRender r1

        //handle rotation inputs
            in r1 %playerinput //rotation
            brz ~+5 r1
                lod r2 rot
                addv r2 r1 r2
                str rot r2
                str needReRender r1

        //handle movement inputs
            in r1 %playerinput //forward movement
            smlt446 r1 r1 SPEEDFACTOR //NOTE: this can be removed to save a few cycles and lose speed customizability
            
            in r2 %amogus_sinyaw
            neg r3 r2
            smlt446 r4 r1 r3 //r3 = velX

            in r3 %amogus_cosyaw
            smlt446 r5 r1 r3 //r4 = velZ
        
        
            in r1 %playerinput //strafe movement
            smlt446 r1 r1 SPEEDFACTOR //NOTE: this can be removed to save a few cycles and lose speed customizability

            smlt446 r6 r1 r2
            add r5 r5 r6 //r5 = velZ

            smlt446 r6 r1 r3
            add r4 r4 r6 //r4 = velX
        
        //handle jumping inputs
            lod r1 onGround
            str onGround 0
            brz .jumpInputNoJump r1
            in r1 %playerinput //is jump pressed?
            brz .jumpInputNoJump r1
            //jump
                imm r1 JUMPSTRENGTH
                str velY r1
                jmp .jumpInputEnd
            .jumpInputNoJump
                lod r1 velY
                sub r1 r1 GRAVITY
                str velY r1
            .jumpInputEnd
        
        //move and collide
            in r0 %blockram_oobactive //tell the blockRAM to return blocks out of bounds
            //prepare stack
                psh r1 //velY
                psh r5 //velZ
                psh r4 //velX //sp+15
                psh %blockram_z
                psh %blockram_x
                psh %blockram_y //sp+12
                psh %blockram_z //sp+11
                psh %blockram_x //sp+10
                psh PLAYERWIDTH
                psh PLAYERWIDTH
                psh PLAYERHEIGHT //sp+7
                psh PLAYERWIDTH //sp+6
                psh PLAYERWIDTH //sp+5
                psh z
                psh x
                psh y //sp+2
                psh z //sp+1
                psh x //sp+0

            .collisionLoop //collide with blocks
                llod r3 sp 0 //r3 = memory location of pos in main axis
                lod r2 r3 //r2 = min pos in main axis before movement
                llod r4 sp 15 //r4 = get velocity in main axis
                add r1 r2 r4 //r1 = min pos in main axis after movement
                str r3 r1 //store position after movement in case no collision detected
                brn ~+4 r4 //if velocity negative, use (-) side of player to collide. Otherwise use (+) side
                    llod r5 sp 5 //r5 = player size in main axis
                    add r1 r1 r5 //r1 = max pos in main axis after movement
                    add r2 r2 r5 //r2 = max pos in main axis before movement
                bsr r2 r2 4 //r2 = block pos in main axis before movement
                bsr r1 r1 4 //r1 = block pos in main axis after movement
                bne ~+3 r2 r1 //if block position doesn't change, don't check collisions in this axis
                    pop r0
                    jmp .collideNoMovement
                bne ~+5 r3 y //only clamp position on the Y axis
                    ble ~+2 r1 BLOCKMIDDLEOFVOID //if min pos is greater than middle of void, it is negative, and should be clamped to 0.
                        imm r1 0
                    ble ~+2 r2 BLOCKMIDDLEOFVOID //if max pos is greater than middle of void, it is negative, and should be clamped to 0.
                        imm r2 0
                //r1 = min block pos in main axis
                //r2 = max block pos in main axis //HACK: having pre-movement position always be max is a bit hacky, but it works for this specific use case with these specific values of max speed in each axis, hitbox size, and gravity. If it ends up being smaller than the min pos, it'll just skip it when it reaches the end of the loop.
                llod r3 sp 1 //r3 = memory location of pos in secondary axis
                lod r3 r3 //r3 = min pos in secondary axis
                llod r4 sp 6 //r4 = player size in secondary axis
                add r4 r3 r4 //r4 = max pos in secondary axis
                bsr r3 r3 4 //r3 = min block pos in secondary axis
                bsr r4 r4 4 //r4 = max block pos in secondary axis
                llod r5 sp 2 //r5 = memory location of pos in tertiary axis
                lod r5 r5 //r5 = min pos in tertiary axis
                llod r6 sp 7 //r6 = player size in tertiary axis
                add r6 r5 r6 //r6 = max pos in tertiary axis
                bsr r5 r5 4 //r5 = min block pos in tertiary axis
                bsr r6 r6 4 //r6 = max block pos in tertiary axis
                psh r5 //min block pos in tertiary axis //NOTE: because more things are being added to stack, the indices from the "prepare stack" section above must be increased by 2 in the following code
                psh r3 //min block pos in secondary axis
                .collideMainAxisLoop
                    llod r7 sp 12 //r7 = port address of main axis output
                    out r7 r1 //send main axis position to blockRAM
                    llod r3 sp 0 //r3 = min block pos in secondary axis
                    .collideSecondaryAxisLoop
                        llod r7 sp 13 //r7 = port address of secondary axis output
                        out r7 r3 //send secondary axis position to blockRAM
                        llod r5 sp 1 //r5 = min block pos in tertiary axis
                        .collideTertiaryAxisLoop
                            llod r7 sp 14 //r7 = port address of tertiary axis output
                            out r7 r5 //send tertiary axis position to blockRAM
                            in r7 %blockram_id //r7 = id of block at this position
                            brz .collideNoCollision r7 //if air, no collision detected
                            bre .collideNoCollision r7 BLOCK_SAPLING //if sapling, no collision detected
                            //collsion detected
                                llod r7 sp 17 //r7 = velocity in main axis
                                brp .collideResolveNegative r7
                                .collideResolvePositive //if velocity is (-), resolve collision in (+) direction
                                    psh r1 //NOTE: must increase stack indices by 1 because another item has been added to stack
                                    bsl r7 r1 4 //r7 = world position of block in main axis
                                    add r7 r7 BLOCKSIZE //r7 = world position of player in main axis
                                    llod r1 sp 3 //r7 = pointer towards player position in main axis
                                    str r1 r7 //store player position
                                    mov r7 r1
                                    pop r1
                                    bne .collideResolveEnd r7 y //if main axis is y axis and collision detected in negative direction, player is on ground
                                        str onGround @max
                                        str velY 0
                                        jmp .collideResolveEnd
                                .collideResolveNegative //if velocity is (+), resolve collision in (-) direction
                                    psh r1 //NOTE: must increase stack indices by 1 because another item has been added to stack
                                    bsl r1 r1 4 //r7 = world position of block in main axis
                                    llod r7 sp 8 //r7 = player size in main axis
                                    inc r7 r7 //r7 = full player size in main axis
                                    sub r7 r1 r7 //r7 = player pos in main axis
                                    llod r1 sp 3 //r1 = RAM pos of main axis position
                                    str r1 r7 //store player position
                                    mov r7 r1
                                    pop r1
                                    bne .collideResolveEnd r7 y //if main axis is y axis and collision detected cancel vertical velocity
                                        str velY 0
                                        jmp .collideResolveEnd
                            .collideNoCollision
                            inc r5 r5 //r5 = teriary axis block pos
                        ble .collideTertiaryAxisLoop r5 r6 //if teriary axis position is <= max tertiary position, do another loop
                        inc r3 r3 //r3 = secondary axis block pos
                    ble .collideSecondaryAxisLoop r3 r4 //if secondary axis position is <= max secondary position, do another loop
                    .collideResolveEnd //if a collision is detected, we don't need to check the other secondary and tertiary axis positions at this main axis position
                    inc r1 r1
                brl .collideMainAxisLoop r1 r2 //if main axis position is < max main position (-1, technically, which is why we use < instead of <=), do another loop
                add sp sp 3 //or pop 3 times
                .collideNoMovement //if no movement was detected in the main axis, skip to here.
                llod r7 sp 0
            bne .collisionLoop r7 x //if next loop starts on X axis, don't do another loop. Always loops 2 times.
            imm sp 52 //reset the stack //NOTE: If the size of the stack before collision detection occurs changes, this value must also change. On CHUNGUS the bottom of the stack is always 255, so this will be 0 on an empty stack. This differs in URCX.

            //collide with bedrock
                lod r1 y
                ble ~+4 r1 MIDDLEOFVOID
                    str y 0
                    str onGround @max
                    str velY 0
        
        in r0 %playerinput //is delete item pressed?

    //do rendering stuff
        //check if render is necessary
            lod r1 needReRender
            bnz .doFullRender r1

            //check if player moved
                lod r1 prevX
                lod r2 x
                str prevX r2
                bne .doFullRender r1 r2

                lod r1 prevY
                lod r2 y
                str prevY r2
                bne .doFullRender r1 r2

                lod r1 prevZ
                lod r2 z
                str prevZ r2
                bne .doFullRender r1 r2
            
            jmp .endFullRender

        .doFullRender
            lod r1 rot
            out %amogus_camrot r1

            lod r1 x
            add r1 r1 PLAYERHALFWIDTH //move from corner of player to middle
            out %amogus_camx r1

            lod r1 z
            add r1 r1 PLAYERHALFWIDTH //move from corner of player to middle
            out %amogus_camz r1

            lod r1 y
            imm r2 PLAYERCAMHEIGHT
            lod r3 crouching
            brz ~+2 r3
                imm r2 PLAYERCROUCHCAMHEIGHT
            add r1 r1 r2 //move to appropriate camera height
            out %amogus_camy r1
        
            in r0 %meshgen_renderscene

            //TODO: render items, chests, furnaces

            in r0 %amogus_drawtoscreen
            in r0 %screen_buffer

            in r0 %amogus_clearbuffer
        .endFullRender

    out %wait 250
    in r0 %wait
jmp .mainLoop


//rayCast function //NOTE: there is still a lot of room for OPTIMimization in this section of code. Most of it can probably be reused instead of repeated.
    //description:
        //casts a ray from the position and direction of the camera, and returns what it hits
    //inputs:
        // x memory location
        // y memory location
        // z memory location
        // some ports
        // some constants
    //outputs:
        //r1: x, z pos of space before first found block
        //r2: y pos of space before first found block
        //r3: x, z pos of first found block
        //r4: y pos of first found block
        //r5: id of first found block (returns air if nothing found, bedrock will return -1)
        //r6: length of raycast (returns -1 if nothing found)
    //storage used:
        //r1 - r7 (not preserved)
        //4 stack positions
.rayCast
    in r0 %blockram_oobinactive //tell the blockram not to return blocks out of bounds

    //initialize values
    lod r1 x
    add r1 r1 PLAYERHALFWIDTH
    and r5 r1 0x0f //r5 = cam x pos in block
    bsr r1 r1 4 //r1 = x block pos

    lod r2 y
    add r2 r2 PLAYERCAMHEIGHT
    and r6 r2 0x0f //r6 = cam y pos in block
    bsr r2 r2 4 //r2 = y block pos

    lod r3 z
    add r3 r3 PLAYERHALFWIDTH
    and r7 r3 0x0f //r7 = cam z pos in block
    bsr r3 r3 4 //r3 = z block pos

    //OPTIM: convert the following repeated code segment into a loop?

    //set up initial X t values
        in r4 %amogus_camdirx
        brn ~+3 r4 //if camDirX positive:
            sub r5 BLOCKSIZE r5 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirX negative:
            neg r4 r4
        sdiv446 r5 r5 r4 //r5 = tMaxX
        sdiv446 r4 0x10 r4 //r4 = tDeltaX
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //set up initial Y t values
        in r4 %amogus_camdiry
        brn ~+3 r4 //if camDirY positive:
            sub r6 BLOCKSIZE r6 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirY negative:
            neg r4 r4
        sdiv446 r6 r6 r4 //r6 = tMaxY
        sdiv446 r4 0x10 r4 //r4 = tDeltaY
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //set up initial Z t values
        in r4 %amogus_camdirz
        brn ~+3 r4 //if camDirZ positive:
            sub r7 BLOCKSIZE r7 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirZ negative:
            neg r4 r4
        sdiv446 r7 r7 r4 //r7 = tMaxZ
        sdiv446 r4 0x10 r4 //r4 = tDeltaZ
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //stack:
        //sp+2: tDeltaX
        //sp+1: tDeltaY
        //sp+0: tDeltaZ
    //regs:
        //r1: x pos
        //r2: Y pos
        //r3: Z pos
        //r4: tDeltaZ
        //r5: x tMaxX
        //r6: y tMaxY
        //r7: z tMaxZ
    
    out %blockram_x r1
    out %blockram_y r2
    out %blockram_z r3
    
    bsl r1 r1 4
    or r3 r1 r3 //r3 = combined xz pos
    mov r4 r2 //r4 = y pos
    
    //OPTIM: make .rayCastFunctionStepX, Y, and Z all use the same code?

    .rayCastFunctionLoop
        //move currentBlock to previousBlock
        mov r1 r3
        mov r2 r4

        brg .rayCastFunctionDontStepX r5 r6 //if (tMaxX <= tMaxY) {rayCastFunctionDontStepX()}
            brg .rayCastFunctionStepZ r5 r7 //if (tMaxX <= tMaxZ) && (tMaxX <= tMaxY) {rayCastFunctionStepX()}
            
                .rayCastFunctionStepX

                    ble ~+4 r5 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdirx
                        brn ~+3 r5 //if camDirX is positive:
                            addv r3 r3 0x10 //increment x
                        jmp ~+2 //if camDirX is negative:
                            subv r3 r3 0x10 //decrement x
                        bsr r5 r3 4
                        out %blockram_x r5

                        //fetch the new block
                            in r5 %blockram_id
                            brz ~+3 r5
                                pop r6 //raycast Length = tMaxX
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 2 //r1 = tDeltaX
                    add r5 r5 r1 //tMaxX = tMaxX + dDeltaX

                jmp .rayCastFunctionLoop

                .rayCastFunctionStepZ

                    ble ~+4 r7 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdirz
                        brn ~+3 r5 //if camDirZ is positive:
                            addv r3 r3 0x01 //increment z
                        jmp ~+2 //if camDirZ is negative:
                            subv r3 r3 0x01 //decrement z
                        and r5 r3 0x0f
                        out %blockram_z r5

                        //fetch the new block
                            in r5 %blockram_id
                            brz ~+4 r5
                                pop r0
                                mov r6 r7 //raycast length = tMaxZ
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 0 //r1 = tDeltaZ
                    add r7 r7 r1 //tMaxZ = tMaxZ + dDeltaZ

                jmp .rayCastFunctionLoop

            .rayCastFunctionDontStepX
            brg .rayCastFunctionStepZ r6 r7

                .rayCastFunctionStepY
                    ble ~+4 r6 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdiry
                        brn ~+3 r5 //if camDirY is positive:
                            inc r4 r4 //increment y
                        jmp ~+2 //if camDirY is negative:
                            dec r4 r4 //decrement y
                        out %blockram_y r4

                        //fetch the new block
                            bne ~+4 r4 -1 //check if y is at bedrock
                                pop r0
                                imm r5 -1 //return bedrock if y = -1
                                jmp .rayCastFunctionEnd
                            in r5 %blockram_id
                            brz ~+3 r5
                                pop r0
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 1 //r1 = tDeltaY
                    add r6 r6 r1 //tMaxY = tMaxY + dDeltaY
                
                jmp .rayCastFunctionLoop
    .rayCastFunctionEnd
        pop r0
        pop r0
        pop r0
ret