bits == 8
minreg 7
minheap 43
minstack 23

//constants
    //size constants
        @define BLOCKSIZE 16
        @define PLAYERWIDTH 9 //technically it's 10, but 9 makes calculations easier
        @define PLAYERHEIGHT 28 //technically it's 29, but 28 makes calculations easier
        @define PLAYERHALFWIDTH 5
        @define PLAYERCAMHEIGHT 24
        @define PLAYERCROUCHCAMHEIGHT 22
        @define MIDDLEOFVOID 0b1100_0000
        @define BLOCKMIDDLEOFVOID 0b1100
    //gameplay constants
        @define GRAVITY 15 //the downwards change in velocity per frame
        @define JUMPSTRENGTH 17 //the initial vertical velocity of a jump
        @define SPEEDFACTOR 0b01_000000 //scales the speed of the characters movement. A value of 1 results in a speed of 4 while crouching, 8 while walking, and 12 while sprinting. In 0bSX.XXXXXX format
        @define RAYCASTMAXLENGTH 0x40 //4 blocks
        @define REQUIREDBREAKSTRENGTH 8
    //other constants
        @define BOTTOMOFSTACK 66 //in URCX: minreg + minheap. in CHUNGUS: 0
    //block IDs
        @define BLOCK_AIR 0x0
        @define BLOCK_grass 0x1
        @define BLOCK_DIRT 0x2
        @define BLOCK_STONE 0x3
        @define BLOCK_COBBLE 0x4
        @define BLOCK_LOG 0x5
        @define BLOCK_LEAVES 0x6
        @define BLOCK_PLANK 0x7
        @define BLOCK_COALORE 0x8
        @define BLOCK_IRONORE 0x9
        @define BLOCK_SAND 0xA
        @define BLOCK_GLASS 0xB
        @define BLOCK_SAPLING 0xC
        @define BLOCK_TABLE 0xD
        @define BLOCK_FURNACE 0xE
        @define BLOCK_CHEST 0xF
    //item IDs
        @define ITEM_AIR 0x00
        @define ITEM_STICK 0x10
        @define ITEM_DIRT 0x20
        @define ITEM_STONE 0x30
        @define ITEM_COBBLE 0x40
        @define ITEM_LOG 0x50
        @define ITEM_LEAVES 0x60
        @define ITEM_PLANK 0x70
        @define ITEM_COAL 0x80
        @define ITEM_IRONORE 0x90
        @define ITEM_SAND 0xA0
        @define ITEM_GLASS 0xB0
        @define ITEM_SAPLING 0xC0
        @define ITEM_IRONINGOT 0xD0
        @define ITEM_APPLE 0xE0
        @define ITEM_NONSTACKABLE 0xF0
    //nonstackable IDs
        @define ITEM_WOODPICKAXE 0xF0
        @define ITEM_WOODAXE 0xF1
        @define ITEM_WOODSHOVEL 0xF2
        @define ITEM_WOODSWORD 0xF3
        @define ITEM_STONEPICKAXE 0xF4
        @define ITEM_STONEAXE 0xF5
        @define ITEM_STONESHOVEL 0xF6
        @define ITEM_STONESWORD 0xF7
        @define ITEM_IRONPICKAXE 0xF8
        @define ITEM_IRONAXE 0xF9
        @define ITEM_IRONSHOVEL 0xFA
        @define ITEM_IRONSWORD 0xFB
        @define ITEM_SHEARS 0xFC
        @define ITEM_TABLE 0xFD
        @define ITEM_FURNACE 0xFE
        @define ITEM_CHEST 0xFF
    //textures
        @define TEXTURE_NUMBER 0x20
        @define TEXTURE_STACKABLE 0x40
        @define TEXTURE_NONSTACKABLE 0x50
        @define TEXTURE_GUI_EMPTY 0x61
        @define TEXTURE_GUI_ARROW 0x63
        @define TEXRURE_GUI_SMELTING 0x65
        @define TEXTURE_INVENTORY 0x70
        @define TEXTURE_CRAFT 0x75
        @define TEXTURE_FURNACE 0x78
        @define TEXTURE_CHEST 0x7C
        @define TEXTURE_HIGHLIGHT0 0x19
        @define TEXTURE_HIGHLIGHT7 0x20

//memory locations
    //OPTIM: it might be worth placing some of these at the base of the stack instead of the heap to reduce cache misses
    @define x m0 //7 bits //NOTE: replace with '0' if 'm0' not supported in translator
    @define y m1 //8 bits
    @define z m2 //7 bits
    @define rot m3 //8 bits
    @define onGround m4 //1 bit //OPTIM: some of these variables (esp. bools) could probably be combined into shared bytes
    @define velY m5 //6 bits
    @define needReRender m6 //1 bit
    @define crouching m7 //1 bit
    @define prevX m8 //7 bits
    @define prevY m9 //8 bits
    @define prevZ m10 //7 bits
    @define prevTargetXZ m11 //8 bits XXXX_ZZZZ
    @define prevTargetY m12 //4 bits
    @define inventory m13 //NOTE: takes up 15 cells (m13-m27), 8 bits each
    @define inventorySlot m28 //8 bits
    //@define breakPhase m29 //8 bits 0PPP_0CCC P=previous C=current //NOTE: this address no longer in use 
    @define targetXZ m30 //8 bits XXXX_ZZZZ
    @define targetY m31 //4 bits
    @define craftingGrid m32 //NOTE: takes up 9 cells (m32-m40), 8 bits each //NOTE: these cells can be used again in portions of the code that don't interfere with crafting.
    @define craftingOutput m41 //8 bits //NOTE: this cell can be used again in portions of the code that don't interfere with crafting
    @define permanentSelectedSlot m42 //8 bits

//initial values
    str x 0x10
    str y 0x20
    str z 0x10
    str rot 0x00
    str onGround @max
    str velY 0
    str needReRender @max
    str crouching 0
    str prevX 0
    str prevY 0
    str prevZ 0
    str prevTargetXZ 0xff
    str prevTargetY 0x0f
    str targetXZ 0xff
    str targetY 0x0f
    str permanentSelectedSlot 0xFF  // outside the inventory

lstr inventory 0 0x14
lstr inventory 1 0x55


.mainLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        //handle miscellaneous inputs
            in r1 %playerinput //is open/close inventory pressed?
            bnz .bank2_loadInventoryGUI r1  //open inventory
            
        .continueFromClosingInventory  // if inventory closed, continue from here

            in r1 %playerinput //inventory movement
            lod r2 inventorySlot
            addv r2 r2 r1
            bne ~+2 r2 5  // rollover to left side of hotbar
                imm r2 0
            bne ~+2 r2 15  // rollover to right side of hotbar
                imm r2 4
            and r2 r2 0x0F  //keep within hotbar
            str inventorySlot r2
        
        //handle break/place
            cal .rayCast
                //r1: x, z pos of space before first found block
                //r2: y pos of space before first found block
                //r3: x, z pos of first found block
                //r4: y pos of first found block
                //r5: id of first found block (returns air if nothing found, bedrock will return -1)
                //r6: length of raycast (returns -1 if nothing found)
            lod r7 targetXZ
            str prevTargetXZ r7
            str targetXZ r3
            sete r6 r3 r7
            lod r7 targetY
            str prevTargetY r7
            str targetY r4
            sete r7 r4 r7
            and r6 r6 r7 //r6 = is the target the same as last frame?
            in r7 %playerinput //r7 = is break pressed?
            lod r6 inventorySlot
            add r6 inventory r6 //r6 = pointer towards item in hand
            lod r6 r6 //r6 = item in hand
            brz .noRayCastHit r5
            brz .endBreakBlock r7
                brn .endBreakBlock r5 //if bedrock, can't break block
                
                //TODO: add block-breaking animation
                    cal .getRayCastTargetQuad
                    //stack:
                        //vert4x sp+15
                        //vert3x sp+14
                        //vert2x sp+13
                        //vert1x sp+12
                        //vert4y sp+11
                        //vert3y sp+10
                        //vert2y sp+9
                        //vert1y sp+8
                        //vert4z sp+7
                        //vert3z sp+6
                        //vert2z sp+5
                        //vert1z sp+4
                        //vert4uv sp+3
                        //vert3uv sp+2
                        //vert2uv sp+1
                        //vert1uv sp+0
                    //TODO: check what item is in hand to get the appropriate strength
                        imm r7 3 //r7 = breaking strength //TEMP: replace '3' with whatever the breaking strength is
                    imm r6 TEXTURE_HIGHLIGHT0
                    .blockBreakAnimLoop
                        cal .buildQuadFromStack
                        out %amogus_settings 0b1101
                        out %amogus_tex r6
                        in r0 %amogus_drawquad //TODO: replace the break textures to only include the new pixels each phase
                        inc r6 r6
                        imm r2 0
                        .blockBreakAnimDelayLoop //this loop lasts shorter the higher breakstrength is
                            add r2 r2 r7
                            out %wait 50 //replace this code on CHUNGUS with any slow code. r1 should currently be free
                            in r0 %wait 
                        ble .blockBreakAnimDelayLoop r2 16
                        in r0 %amogus_drawtoscreen
                        in r0 %screen_buffer
                        //TODO: convert drawUI into a function, and call it from here as well as when rendering at the end
                    brl .blockBreakAnimLoop r6 TEXTURE_HIGHLIGHT7
                    imm sp BOTTOMOFSTACK //refresh stack after using .getRayCastTargetQuad
                bsr r7 r3 4
                out %blockram_x r7
                and r7 r3 0x0f
                out %blockram_z r7
                out %blockram_y r4
                //TODO: drop item entity if the held tool is appropriate
                out %blockram_id 0 //replace targeted block with air
                //TODO: check if block above this block is sand, if so, make it fall
                str needReRender @max
                in r0 %playerinput //keep playerInput device synced
                jmp .endBreakAndPlace
            .endBreakBlock
            in r7 %playerinput //is place pressed?
            brz .endBreakAndPlace r7
                lod r7 crouching
                //TODO: check if targeted block is usable, if so, use it
                //TODO: check if item in hand is usable without target, if so, jump to .useNonPlaceable
                //TODO: check if item in hand is placeable, if so place it
                bsr r7 r1 4
                out %blockram_x r7
                and r7 r1 0x0f
                out %blockram_z r7
                out %blockram_y r2
                out %blockram_id BLOCK_GRASS //TEMP: replace grass with whatever is currently held
                str needReRender @max
            jmp .endBreakAndPlace
            .noRayCastHit
                str targetXZ 0xff
                str targetY 0x0f
                in r7 %playerinput //is place pressed?
                //TODO: check if item in hand is usable without a target, if not, skip to .endBreakAndPlace
            .useNonPlaceable
                //TODO: use nonplaceable items
        .endBreakAndPlace

        //handle crouching inputs
            in r1 %playerinput //is crouch pressed?
            lod r2 crouching
            bre ~+3 r1 r2 //if crouching status changed:
                str crouching r1
                str needReRender r1

        //handle rotation inputs
            in r1 %playerinput //rotation
            brz ~+5 r1
                lod r2 rot
                addv r2 r1 r2
                str rot r2
                str needReRender r1

        //handle movement inputs
            in r1 %playerinput //forward movement
            smlt446 r1 r1 SPEEDFACTOR //NOTE: this can be removed to save a few cycles and lose speed customizability
            
            in r2 %amogus_sinyaw
            neg r3 r2
            smlt446 r4 r1 r3 //r3 = velX

            in r3 %amogus_cosyaw
            smlt446 r5 r1 r3 //r4 = velZ
        
        
            in r1 %playerinput //strafe movement
            smlt446 r1 r1 SPEEDFACTOR //NOTE: this can be removed to save a few cycles and lose speed customizability

            smlt446 r6 r1 r2
            add r5 r5 r6 //r5 = velZ

            smlt446 r6 r1 r3
            add r4 r4 r6 //r4 = velX
        
        //handle jumping inputs
            lod r1 onGround
            str onGround 0
            brz .jumpInputNoJump r1
            in r1 %playerinput //is jump pressed?
            brz .jumpInputNoJump r1
            //jump
                imm r1 JUMPSTRENGTH
                str velY r1
                jmp .jumpInputEnd
            .jumpInputNoJump
                lod r1 velY
                sub r1 r1 GRAVITY
                str velY r1
            .jumpInputEnd
        
        //move and collide
            in r0 %blockram_oobactive //tell the blockRAM to return blocks out of bounds
            //prepare stack
                psh r1 //velY
                psh r5 //velZ
                psh r4 //velX //sp+15
                psh %blockram_z
                psh %blockram_x
                psh %blockram_y //sp+12
                psh %blockram_z //sp+11
                psh %blockram_x //sp+10
                psh PLAYERWIDTH
                psh PLAYERWIDTH
                psh PLAYERHEIGHT //sp+7
                psh PLAYERWIDTH //sp+6
                psh PLAYERWIDTH //sp+5
                psh z
                psh x
                psh y //sp+2
                psh z //sp+1
                psh x //sp+0

            .collisionLoop //collide with blocks
                llod r3 sp 0 //r3 = memory location of pos in main axis
                lod r2 r3 //r2 = min pos in main axis before movement
                llod r4 sp 15 //r4 = get velocity in main axis
                add r1 r2 r4 //r1 = min pos in main axis after movement
                str r3 r1 //store position after movement in case no collision detected
                brn ~+4 r4 //if velocity negative, use (-) side of player to collide. Otherwise use (+) side
                    llod r5 sp 5 //r5 = player size in main axis
                    add r1 r1 r5 //r1 = max pos in main axis after movement
                    add r2 r2 r5 //r2 = max pos in main axis before movement
                bsr r2 r2 4 //r2 = block pos in main axis before movement
                bsr r1 r1 4 //r1 = block pos in main axis after movement
                bne ~+3 r2 r1 //if block position doesn't change, don't check collisions in this axis
                    pop r0
                    jmp .collideNoMovement
                bne ~+5 r3 y //only clamp position on the Y axis
                    ble ~+2 r1 BLOCKMIDDLEOFVOID //if min pos is greater than middle of void, it is negative, and should be clamped to 0.
                        imm r1 0
                    ble ~+2 r2 BLOCKMIDDLEOFVOID //if max pos is greater than middle of void, it is negative, and should be clamped to 0.
                        imm r2 0
                //r1 = min block pos in main axis
                //r2 = max block pos in main axis //HACK: having pre-movement position always be max is a bit hacky, but it works for this specific use case with these specific values of max speed in each axis, hitbox size, and gravity. If it ends up being smaller than the min pos, it'll just skip it when it reaches the end of the loop.
                llod r3 sp 1 //r3 = memory location of pos in secondary axis
                lod r3 r3 //r3 = min pos in secondary axis
                llod r4 sp 6 //r4 = player size in secondary axis
                add r4 r3 r4 //r4 = max pos in secondary axis
                bsr r3 r3 4 //r3 = min block pos in secondary axis
                bsr r4 r4 4 //r4 = max block pos in secondary axis
                llod r5 sp 2 //r5 = memory location of pos in tertiary axis
                lod r5 r5 //r5 = min pos in tertiary axis
                llod r6 sp 7 //r6 = player size in tertiary axis
                add r6 r5 r6 //r6 = max pos in tertiary axis
                bsr r5 r5 4 //r5 = min block pos in tertiary axis
                bsr r6 r6 4 //r6 = max block pos in tertiary axis
                psh r5 //min block pos in tertiary axis //NOTE: because more things are being added to stack, the indices from the "prepare stack" section above must be increased by 2 in the following code
                psh r3 //min block pos in secondary axis
                .collideMainAxisLoop
                    llod r7 sp 12 //r7 = port address of main axis output
                    out r7 r1 //send main axis position to blockRAM
                    llod r3 sp 0 //r3 = min block pos in secondary axis
                    .collideSecondaryAxisLoop
                        llod r7 sp 13 //r7 = port address of secondary axis output
                        out r7 r3 //send secondary axis position to blockRAM
                        llod r5 sp 1 //r5 = min block pos in tertiary axis
                        .collideTertiaryAxisLoop
                            llod r7 sp 14 //r7 = port address of tertiary axis output
                            out r7 r5 //send tertiary axis position to blockRAM
                            in r7 %blockram_id //r7 = id of block at this position
                            brz .collideNoCollision r7 //if air, no collision detected
                            bre .collideNoCollision r7 BLOCK_SAPLING //if sapling, no collision detected
                            //collsion detected
                                llod r7 sp 17 //r7 = velocity in main axis
                                brp .collideResolveNegative r7
                                .collideResolvePositive //if velocity is (-), resolve collision in (+) direction
                                    psh r1 //NOTE: must increase stack indices by 1 because another item has been added to stack
                                        bsl r7 r1 4 //r7 = world position of block in main axis
                                        add r7 r7 BLOCKSIZE //r7 = world position of player in main axis
                                        llod r1 sp 3 //r7 = pointer towards player position in main axis
                                        str r1 r7 //store player position
                                        mov r7 r1
                                    pop r1
                                    bne .collideResolveEnd r7 y //if main axis is y axis and collision detected in negative direction, player is on ground
                                        str onGround @max
                                        str velY 0
                                        jmp .collideResolveEnd
                                .collideResolveNegative //if velocity is (+), resolve collision in (-) direction
                                    psh r1 //NOTE: must increase stack indices by 1 because another item has been added to stack
                                        bsl r1 r1 4 //r7 = world position of block in main axis
                                        llod r7 sp 8 //r7 = player size in main axis
                                        inc r7 r7 //r7 = full player size in main axis
                                        sub r7 r1 r7 //r7 = player pos in main axis
                                        llod r1 sp 3 //r1 = RAM pos of main axis position
                                        str r1 r7 //store player position
                                        mov r7 r1
                                    pop r1
                                    bne .collideResolveEnd r7 y //if main axis is y axis and collision detected cancel vertical velocity
                                        str velY 0
                                        jmp .collideResolveEnd
                            .collideNoCollision
                            inc r5 r5 //r5 = teriary axis block pos
                        ble .collideTertiaryAxisLoop r5 r6 //if teriary axis position is <= max tertiary position, do another loop
                        inc r3 r3 //r3 = secondary axis block pos
                    ble .collideSecondaryAxisLoop r3 r4 //if secondary axis position is <= max secondary position, do another loop
                    .collideResolveEnd //if a collision is detected, we don't need to check the other secondary and tertiary axis positions at this main axis position
                    inc r1 r1
                brl .collideMainAxisLoop r1 r2 //if main axis position is < max main position (-1, technically, which is why we use < instead of <=), do another loop
                add sp sp 3 //or pop 3 times
                .collideNoMovement //if no movement was detected in the main axis, skip to here.
                llod r7 sp 0
            bne .collisionLoop r7 x //if next loop starts on X axis, don't do another loop. Always loops 2 times.
            imm sp BOTTOMOFSTACK //reset the stack //NOTE: If the size of the stack before collision detection occurs changes, this value must also change.

            //collide with bedrock
                lod r1 y
                ble ~+4 r1 MIDDLEOFVOID
                    str y 0
                    str onGround @max
                    str velY 0
        
        in r0 %playerinput //is delete item pressed?

    //do rendering stuff
        //check if full render is necessary
            lod r1 needReRender
            bnz .doFullRender r1

            //check if player moved
                lod r1 prevX
                lod r2 x
                str prevX r2
                bne .doFullRender r1 r2

                lod r1 prevY
                lod r2 y
                str prevY r2
                bne .doFullRender r1 r2

                lod r1 prevZ
                lod r2 z
                str prevZ r2
                bne .doFullRender r1 r2
            
        //if full render not necessary:
            imm r1 50 //TEMP: this simulates a faster frame when you don't need to simulate the entire sccene.
        jmp .renderUI

        .doFullRender
            in r0 %amogus_clearbuffer

            lod r1 rot
            out %amogus_camrot r1

            lod r1 x
            add r1 r1 PLAYERHALFWIDTH //move from corner of player to middle
            out %amogus_camx r1

            lod r1 z
            add r1 r1 PLAYERHALFWIDTH //move from corner of player to middle
            out %amogus_camz r1

            lod r1 y
            imm r2 PLAYERCAMHEIGHT
            lod r3 crouching
            brz ~+2 r3
                imm r2 PLAYERCROUCHCAMHEIGHT
            add r1 r1 r2 //move to appropriate camera height
            out %amogus_camy r1
        
            in r0 %meshgen_renderscene

            //TODO: render chests and furnace faces

            //render target highlight
                cal .rayCast
                brz ~+7 r5 //if raycast hits nothing, don't render a highlight
                    cal .getRayCastTargetQuad
                    cal .buildQuadFromStack
                    out %amogus_settings 0b1101
                    out %amogus_tex TEXTURE_HIGHLIGHT0
                    in r0 %amogus_drawquad
                    imm sp BOTTOMOFSTACK //refresh stack after using .getRayCastTargetQuad

            //TODO: render item entities

            in r0 %amogus_drawtoscreen
            imm r1 @max //TEMP: this simulates the lag from drawing the entire screen in-game
        .renderUI
            out %wait r1 //TEMP: r1 is set based on what type of frame was drawn. Full-render frames are much slower.
            in r0 %wait
            // draw hotbar
                // draw highlight (black rectangle around hotbar)
                out %screen_x1 19  // top left x
                out %screen_y1 51  // top left y
                out %screen_x2 76  // bottom right x
                out %screen_y2_clearrect 63  // bottom right y
                // draw borders
                out %screen_x1 20  // top left x
                out %screen_y1 52  // top left y
                out %screen_x2 75  // bottom right x
                out %screen_y2_drawrect 63  // bottom right y
                // draw items
                imm r1 21  // top left x
                imm r2 53  // top left y
                imm r5 5  // length of hotbar
                imm r6 inventory  // load memory address of hotbar items
                lod r7 inventorySlot  // get selected item
                cal .drawGUIRow

    //do end of frame cleanup + wait for next frame
        in r0 %screen_buffer
        str needReRender 0
jmp .mainLoop


//rayCast function //OPTIM: there is still a lot of room for optimization in this section of code. Most of it can probably be reused instead of repeated.
    //description:
        //casts a ray from the position and direction of the camera, and returns what it hits
    //inputs:
        // x memory location
        // y memory location
        // z memory location
        // some ports
        // some constants
    //outputs:
        //r1: x, z pos of space before first found block
        //r2: y pos of space before first found block
        //r3: x, z pos of first found block
        //r4: y pos of first found block
        //r5: id of first found block (returns air if nothing found, bedrock will return -1)
        //r6: length of raycast (returns -1 if nothing found)
    //storage used:
        //r1 - r7 (not preserved)
        //4 stack positions
.rayCast
    in r0 %blockram_oobinactive //tell the blockram not to return blocks out of bounds

    //initialize values
    lod r1 x
    add r1 r1 PLAYERHALFWIDTH
    and r5 r1 0x0f //r5 = cam x pos in block
    bsr r1 r1 4 //r1 = x block pos

    lod r2 y
    add r2 r2 PLAYERCAMHEIGHT
    and r6 r2 0x0f //r6 = cam y pos in block
    bsr r2 r2 4 //r2 = y block pos

    lod r3 z
    add r3 r3 PLAYERHALFWIDTH
    and r7 r3 0x0f //r7 = cam z pos in block
    bsr r3 r3 4 //r3 = z block pos

    //OPTIM: convert the following repeated code segment into a loop?

    //set up initial X t values
        in r4 %amogus_camdirx
        brn ~+3 r4 //if camDirX positive:
            sub r5 BLOCKSIZE r5 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirX negative:
            neg r4 r4
        sdiv446 r5 r5 r4 //r5 = tMaxX
        sdiv446 r4 0x10 r4 //r4 = tDeltaX
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //set up initial Y t values
        in r4 %amogus_camdiry
        brn ~+3 r4 //if camDirY positive:
            sub r6 BLOCKSIZE r6 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirY negative:
            neg r4 r4
        sdiv446 r6 r6 r4 //r6 = tMaxY
        sdiv446 r4 0x10 r4 //r4 = tDeltaY
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //set up initial Z t values
        in r4 %amogus_camdirz
        brn ~+3 r4 //if camDirZ positive:
            sub r7 BLOCKSIZE r7 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirZ negative:
            neg r4 r4
        sdiv446 r7 r7 r4 //r7 = tMaxZ
        sdiv446 r4 0x10 r4 //r4 = tDeltaZ
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //stack:
        //sp+2: tDeltaX
        //sp+1: tDeltaY
        //sp+0: tDeltaZ
    //regs:
        //r1: x pos
        //r2: Y pos
        //r3: Z pos
        //r4: tDeltaZ
        //r5: x tMaxX
        //r6: y tMaxY
        //r7: z tMaxZ
    
    out %blockram_x r1
    out %blockram_y r2
    out %blockram_z r3
    
    bsl r1 r1 4
    or r3 r1 r3 //r3 = combined xz pos
    mov r4 r2 //r4 = y pos
    
    //OPTIM: make .rayCastFunctionStepX, Y, and Z all use the same code?

    .rayCastFunctionLoop
        //move currentBlock to previousBlock
        mov r1 r3
        mov r2 r4

        brg .rayCastFunctionDontStepX r5 r6 //if (tMaxX <= tMaxY) {rayCastFunctionDontStepX()}
            brg .rayCastFunctionStepZ r5 r7 //if (tMaxX <= tMaxZ) && (tMaxX <= tMaxY) {rayCastFunctionStepX()}
            
                .rayCastFunctionStepX

                    ble ~+4 r5 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdirx
                        brn ~+3 r5 //if camDirX is positive:
                            addv r3 r3 0x10 //increment x
                        jmp ~+2 //if camDirX is negative:
                            subv r3 r3 0x10 //decrement x
                        bsr r5 r3 4
                        out %blockram_x r5

                        //fetch the new block
                            in r5 %blockram_id
                            brz ~+3 r5
                                pop r6 //raycast Length = tMaxX
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 2 //r1 = tDeltaX
                    add r5 r5 r1 //tMaxX = tMaxX + dDeltaX

                jmp .rayCastFunctionLoop

                .rayCastFunctionStepZ

                    ble ~+4 r7 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdirz
                        brn ~+3 r5 //if camDirZ is positive:
                            addv r3 r3 0x01 //increment z
                        jmp ~+2 //if camDirZ is negative:
                            subv r3 r3 0x01 //decrement z
                        and r5 r3 0x0f
                        out %blockram_z r5

                        //fetch the new block
                            in r5 %blockram_id
                            brz ~+4 r5
                                pop r0
                                mov r6 r7 //raycast length = tMaxZ
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 0 //r1 = tDeltaZ
                    add r7 r7 r1 //tMaxZ = tMaxZ + dDeltaZ

                jmp .rayCastFunctionLoop

            .rayCastFunctionDontStepX
            brg .rayCastFunctionStepZ r6 r7

                .rayCastFunctionStepY
                    ble ~+4 r6 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdiry
                        brn ~+3 r5 //if camDirY is positive:
                            inc r4 r4 //increment y
                        jmp ~+2 //if camDirY is negative:
                            dec r4 r4 //decrement y
                        out %blockram_y r4

                        //fetch the new block
                            bne ~+4 r4 -1 //check if y is at bedrock
                                pop r0
                                imm r5 -1 //return bedrock if y = -1
                                jmp .rayCastFunctionEnd
                            in r5 %blockram_id
                            brz ~+3 r5
                                pop r0
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 1 //r1 = tDeltaY
                    add r6 r6 r1 //tMaxY = tMaxY + dDeltaY
                
                jmp .rayCastFunctionLoop
    .rayCastFunctionEnd
        pop r0
        pop r0
        pop r0
ret


.getRayCastTargetQuad 
    //get quad vertices //OPTIM: there is almost certainly a better way to do this
        brg .targetPosYQuad r2 r4
        brl .targetNegYQuad r2 r4
        and r6 r1 0xf0 //r6 = rayCastPrevX
        and r7 r3 0xf0 //r7 = rayCastcurrX
        brg .targetPosXQuad r6 r7
        brl .targetNegXQuad r6 r7
        and r6 r1 0x0f //r6 = rayCastPrevZ
        and r7 r3 0x0f //r7 = rayCastcurrZ
        brg .targetPosZQuad r6 r7
        //brl .targetNegXQuad r6 r7
        .targetNegZQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            sub r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            psh r7 //vert4z
            psh r7 //vert3z
            psh r7 //vert2z
            psh r7 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetPosZQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y

            psh r6 //vert4x
            psh r6 //vert3x
            add r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r6 //vert4z
            psh r6 //vert3z
            psh r6 //vert2z
            psh r6 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetNegXQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y

            psh r6 //vert4x
            psh r6 //vert3x
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r7 //vert4z
            psh r7 //vert3z
            psh r6 //vert2z
            psh r6 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetPosXQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r6 //vert4z
            psh r6 //vert3z
            psh r7 //vert2z
            psh r7 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetNegYQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            sub r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r6 //vert4z
            psh r7 //vert3z
            psh r7 //vert2z
            psh r6 //vert1z

            bsl r7 r4 4
            psh r7 //vert4y
            psh r7 //vert3y
            psh r7 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetPosYQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            sub r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r7 //vert4z
            psh r6 //vert3z
            psh r6 //vert2z
            psh r7 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r6 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r6 //vert1y
        .endGetQuad
        psh 0x80 //vert4uv
        psh 0x88 //vert3uv
        psh 0x08 //vert2uv
        psh 0x00 //vert1uv
ret //NOTE: this only works with a callstack because of stack stuff

.buildQuadFromStack
    psh r0
    psh r0
    psh r0
    psh r0 //add 4 junk values to stack so we can safely pop them.
    imm r2 0
    .buildQuadFromStackLoop
        llod r1 sp 4
        out %amogus_vertuv r1
        llod r1 sp 8
        out %amogus_verty r1
        llod r1 sp 12
        out %amogus_vertz r1
        llod r1 sp 16 //NOTE: there are ways to decrease this number if it's too large
        out %amogus_vertx r1
        in r0 %amogus_submitvert
        inc r2 r2
        pop r0 //on CHUNGUS, this can be combined with the last LLOD instruction
    brl .buildQuadFromStackLoop r2 4 //loop exactly 4 times
ret


//drawItem function
    //description:
        // draws an item at given x,y
        // where x,y is the top left corner of area (1 top/left of the item itself)
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
        // r3: item
        // r4: is item selected? (0 = selected, anything else = not selected)
    //outputs:
        // none
    //storage used:
        // none
.drawItem
    // draw first rectangle
    out %screen_x1 r1
    out %screen_y1 r2
    add r1 r1 9  // x2
    add r2 r2 9  // y2
    out %screen_x2 r1
    out %screen_y2 r2
    sub r1 r1 8  // adjust x, y to correct position to draw item itself
    sub r2 r2 8
    // check if rectangle needs to be filled or emptied
    bnz .drawItemNotSelected r4

        // draw selected outline
        in r0 %screen_drawrect
        out %screen_x1 r1  // load inner rectangle coordinates
        out %screen_y1 r2
        add r1 r1 7  // x2
        add r2 r2 7  // y2
        out %screen_x2 r1
        out %screen_y2 r2
        sub r1 r1 7  // adjust x, y back to correct position
        sub r2 r2 7

    .drawItemNotSelected
    in r0 %screen_clearrect  // clear inner rectangle
    bnz .drawItemNonZero r3  // check if item exists (ie. not 00000000)

        .drawItemReturn
        sub r1 r1 1  // preserve x,y
        sub r2 r2 1
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .drawItemNonZero
    out %screen_x1 r1  // load correct x1, y1
    out %screen_y1 r2
    bge .drawItemNonstackable r3 0xF0 // check if item is nonstackable
        // draw stackable item
        bsr r4 r3 4  // get item id
        add r4 r4 TEXTURE_STACKABLE  // draw item texture
        out %screen_texid_drawtex r4

        // draw item count
        and r3 r3 0x0F  // get item count
        add r3 r3 TEXTURE_NUMBER  // get background texture
        add r1 r1 2  // move x,y over to correct position
        add r2 r2 2
        out %screen_x1 r1  // draw background texture
        out %screen_y1 r2
        out %screen_texid_drawtex r3
        add r3 r3 0x10  // get number texture
        out %screen_texid_drawinvtex r3

        // return
        sub r1 r1 3  // preserve x,y
        sub r2 r2 3
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .drawItemNonstackable
        // draw nonstackable item
        and r3 r3 0x0F  // get item id
        add r3 r3 TEXTURE_NONSTACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        jmp .drawItemReturn  // return
// end drawItem function


//drawGUIRow function
    //description:
        // draws a row of items of length r5 starting at x,y
        // pointed to by r6 in memory with r7 selected
    //inputs:
        // r1: x
        // r2: y
        // r5: length
        // r6: memory address of first item
        // r7: item in row selected (>length = none selected)
    //outputs:
        // none
    //storage used:
        // none
.drawGUIRow
    sub r7 r5 r7  // get loop index of selected item
    .drawGUIRowLoop
        lod r3 r6  // get item
        sub r4 r5 r7  // check if selected (r7 == r5)
        cal .drawItem  // draw item
        add r1 r1 11  // increase x by slot size
        add r6 r6 1  // increase memory index
        sub r5 r5 1  // decrease loop counter
        bnz .drawGUIRowLoop r5 // loop if not done yet
    ret  // return
// end drawGUIRow function









// get slot x,y and memory address from id
.bank2_multiplyXAndYBy11
    add r7 r7 r5  // adjust memory address by x
    mlt r5 r5 11  // multiply
    mlt r6 r6 11
ret
.bank2_inventoryGetSlot
    // r5: x (returned)
    // r6: y (returned)
    // r7: slot, address (returned)
    // NOTE: for chests and furnaces (tile entitites), return address is relative within them
    bsr r6 r7 4  // split x and y
    and r5 r7 0x0F  // x

    bge ~+6 r7 0x10  // on hotbar
        imm r7 inventory  // memory address
        cal .bank2_multiplyXAndYBy11
        imm r6 53  // y
        add r5 r5 21  // x
        ret
    bge ~+7 r7 0x30  // within main inventory
        mlt r7 r6 5  // memory address
        add r7 r7 inventory
        cal .bank2_multiplyXAndYBy11
        sub r6 52 r6  // y
        add r5 r5 21  // x
        ret
    bge ~+7 r7 0x50  // within chest
        sub r6 r6 3
        mlt r7 r6 5  // memory address
        cal .bank2_multiplyXAndYBy11
        sub r6 18 r6  // y
        add r5 r5 21  // x
        ret
    bge ~+11 r7 0x70  // within small crafting grid
        sub r6 6 r6
        mlt r7 r6 3  // memory address
        sub r6 1 r6
        add r7 r7 craftingGrid
        add r7 r7 r5  // adjust memory address by x
        mlt r5 r5 9  // multiply
        mlt r6 r6 9
        sub r6 18 r6  // y
        add r5 r5 26  // x
        ret
    bge ~+11 r7 0xA0  // within large crafting grid
        sub r6 9 r6
        mlt r7 r6 3  // memory address
        sub r6 2 r6
        add r7 r7 craftingGrid
        add r7 r7 r5  // adjust memory address by x
        mlt r5 r5 9  // multiply
        mlt r6 r6 9
        sub r6 19 r6  // y
        add r5 r5 21  // x
        ret
    // TODO: furnace

    imm r6 0xFF  // out of bounds
ret

//bank2_drawItem function
    //description:
        // draws an item at given x,y
        // where x,y is the top left corner of area (1 top/left of the item itself)
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
        // r3: item
        // r4: is item selected? (0 = selected, anything else = not selected)
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawItem
    // draw first rectangle
    out %screen_x1 r1
    out %screen_y1 r2
    add r1 r1 9  // x2
    add r2 r2 9  // y2
    out %screen_x2 r1
    out %screen_y2 r2
    sub r1 r1 8  // adjust x, y to correct position to draw item itself
    sub r2 r2 8
    // check if rectangle needs to be filled or emptied
    bnz .bank2_drawItemNotSelected r4

        // draw selected outline
        in r0 %screen_drawrect
        out %screen_x1 r1  // load inner rectangle coordinates
        out %screen_y1 r2
        add r1 r1 7  // x2
        add r2 r2 7  // y2
        out %screen_x2 r1
        out %screen_y2 r2
        sub r1 r1 7  // adjust x, y back to correct position
        sub r2 r2 7

    .bank2_drawItemNotSelected
    in r0 %screen_clearrect  // clear inner rectangle
    bnz .bank2_drawItemNonZero r3  // check if item exists (ie. not 00000000)

        .bank2_drawItemReturn
        sub r1 r1 1  // preserve x,y
        sub r2 r2 1
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .bank2_drawItemNonZero
    out %screen_x1 r1  // load correct x1, y1
    out %screen_y1 r2
    bge .bank2_drawItemNonstackable r3 0xF0 // check if item is nonstackable
        // draw stackable item
        bsr r4 r3 4  // get item id
        add r4 r4 TEXTURE_STACKABLE  // draw item texture
        out %screen_texid_drawtex r4

        // draw item count
        and r3 r3 0x0F  // get item count
        add r3 r3 TEXTURE_NUMBER  // get background texture
        add r1 r1 2  // move x,y over to correct position
        add r2 r2 2
        out %screen_x1 r1  // draw background texture
        out %screen_y1 r2
        out %screen_texid_drawtex r3
        add r3 r3 0x10  // get TEXTURE_number texture
        out %screen_texid_drawinvtex r3

        // return
        sub r1 r1 3  // preserve x,y
        sub r2 r2 3
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .bank2_drawItemNonstackable
        // draw nonstackable item
        and r3 r3 0x0F  // get item id
        add r3 r3 TEXTURE_NONSTACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        jmp .bank2_drawItemReturn  // return
// end bank2_drawItem function


//bank2_drawGUIRow function
    //description:
        // draws a row of items of length r5 starting at x,y
        // pointed to by r6 in memory with r7 selected
    //inputs:
        // r1: x
        // r2: y
        // r5: length
        // r6: memory address of first item
        // r7: item in row selected (>length = none selected)
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawGUIRow
    sub r7 r5 r7  // get loop index of selected item
    .bank2_drawGUIRowLoop
        lod r3 r6  // get item
        sub r4 r5 r7  // check if selected (r7 == r5)
        cal .bank2_drawItem  // draw item
        add r1 r1 11  // increase x by slot size
        add r6 r6 1  // increase memory index
        sub r5 r5 1  // decrease loop counter
        bnz .bank2_drawGUIRowLoop r5 // loop if not done yet
    ret  // return
// end bank2_drawGUIRow function


.bank2_highlightRectangle1
    out %screen_x1 r1
    out %screen_y1 r2
    out %screen_y2 r2
    add r1 r1 9
    out %screen_x2 r1
ret

.bank2_highlightRectangle2
    out %screen_x1 r1
    add r2 r2 9
    out %screen_y2 r2
ret

.bank2_highlightRectangle3
    out %screen_y1 r2
    sub r1 r1 9
    out %screen_x1 r1
ret

.bank2_highlightRectangle4
    out %screen_x2 r1
    sub r2 r2 9
    out %screen_y1 r2
ret

//bank2_drawHighlight function
    //description:
        // draws a highlight around the item at x,y
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
.bank2_drawHighlight
    cal .bank2_highlightRectangle1
    in r0 %screen_drawrect
    cal .bank2_highlightRectangle2
    in r0 %screen_drawrect
    cal .bank2_highlightRectangle3
    in r0 %screen_drawrect
    cal .bank2_highlightRectangle4
    in r0 %screen_drawrect
ret


//bank2_clearHighlight function
    //description:
        // clears the highlight around the item at x,y
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
.bank2_clearHighlight
    cal .bank2_highlightRectangle1
    in r0 %screen_clearrect
    cal .bank2_highlightRectangle2
    in r0 %screen_clearrect
    cal .bank2_highlightRectangle3
    in r0 %screen_clearrect
    cal .bank2_highlightRectangle4
    in r0 %screen_clearrect
ret


//bank2_drawItemInGrid function
    //description:
        // draws an item at given x,y within a GUI grid
        // where x,y is the top left corner of area (1 top/left of the item itself)
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
        // r3: item
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawItemInGrid
    // clear rectangle
    add r1 r1 1  // x1
    add r2 r2 1  // y1
    out %screen_x1 r1
    out %screen_y1 r2
    add r1 r1 7  // x2
    add r2 r2 7  // y2
    out %screen_x2 r1
    out %screen_y2 r2
    sub r1 r1 7  // adjust x, y to correct position to draw item itself
    sub r2 r2 7
    in r0 %screen_clearrect

    out %screen_x1 r1  // load correct x1, y1
    out %screen_y1 r2
    bnz .bank2_drawItemInGridNonZero r3  // check if item exists (ie. not 00000000)

        out %screen_texid_drawtex TEXTURE_GUI_EMPTY  // draw empty item
        .bank2_drawItemInGridReturn
        sub r1 r1 1  // preserve x,y
        sub r2 r2 1
        ret

    .bank2_drawItemInGridNonZero
    bge .bank2_drawItemInGridNonstackable r3 0xF0 // check if item is nonstackable
        // draw stackable item
        bsr r3 r3 4  // get item id
        add r3 r3 TEXTURE_STACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        // no need to draw item count as at most 1 in grid
        jmp .bank2_drawItemInGridReturn  // return

    .bank2_drawItemInGridNonstackable
        // draw nonstackable item
        and r3 r3 0x0F  // get item id
        add r3 r3 TEXTURE_NONSTACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        jmp .bank2_drawItemInGridReturn  // return
// end bank2_drawItemInGrid function


//bank2_drawGUIRowInGrid function
    //description:
        // draws a row of items of length r5 starting at x,y
        // pointed to by r6 in memory with r7 selected
    //inputs:
        // r1: x
        // r2: y
        // r5: length
        // r6: memory address of first item
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawGUIRowInGrid
    .bank2_drawGUIRowInGridLoop
        lod r3 r6  // get item
        cal .bank2_drawItemInGrid  // draw item
        in r0 %screen_nop  // ensure screen queue cleared
        add r1 r1 9  // increase x by slot size
        add r6 r6 1  // increase memory index
        sub r5 r5 1  // decrease loop counter
        bnz .bank2_drawGUIRowInGridLoop r5 // loop if not done yet
    ret  // return
// end bank2_drawGUIRowInGrid function


// draw the inventory part of a GUI
.bank2_drawInventory
    // draw highlight (black rectangle around GUI)
    out %screen_x1 19  // top left x
    out %screen_y1 0  // top left y
    out %screen_x2 76  // bottom right x
    out %screen_y2_clearrect 63  // bottom right y

    // draw borders
    out %screen_x1 20  // top left x
    out %screen_y1 0  // top left y
    out %screen_x2 75  // bottom right x
    out %screen_y2_drawrect 63  // bottom right y

.bank2_drawInventoryOnlyInventoryPart  // skip the top half
    // draw highlight (black rectangle around GUI)
    out %screen_x1 19  // top left x
    out %screen_y1 29  // top left y
    out %screen_x2 76  // bottom right x
    out %screen_y2_clearrect 63  // bottom right y

    // draw borders
    out %screen_x1 20  // top left x
    out %screen_y1 29  // top left y
    out %screen_x2 75  // bottom right x
    out %screen_y2_drawrect 63  // bottom right y

    // draw items
    imm r1 21  // top left X
    imm r2 53  // top left y
    imm r5 5  // length
    imm r6 inventory  // first item
    lod r7 inventorySlot  // selected item
    cal .bank2_drawGUIRow  // draw row of items

    sub r2 r2 12  // move up a row in y coordinate
    imm r1 21  // top left X
    imm r5 5  // length
    lod r7 inventorySlot  // selected item
    sub r7 r7 0x10  // move up a row in selected item
    cal .bank2_drawGUIRow  // draw row of items

    sub r2 r2 11  // move up a row in y coordinate
    imm r1 21  // top left X
    imm r5 5  // length
    lod r7 inventorySlot  // selected item
    sub r7 r7 0x20  // move up a row in selected item
    cal .bank2_drawGUIRow  // draw row of items
ret


.bank2_addItemToInventory
    // input: r7 (item)
    // other registers not necessarily preserved
    imm r1 0
    and r6 r7 0xF0  // item id
    .bank2_addItemToInventoryLoop
        add r1 r1 inventory  // check what item is already there
        lod r2 r1
        bnz ~+3 r2  // no item
            str r1 r7  // store regardless of what it is
            ret  // done
        bge .bank2_addItemToInventoryLoopContinue r7 0xF0  // skip if nonstackable
        and r3 r2 0xF0  // get item id
        bne .bank2_addItemToInventoryLoopContinue r6 r3  // skip if not same item id
            and r4 r2 0x0F  // get item counts
            and r5 r7 0x0F
            add r5 r4 r5  // get sum
            bge .bank2_addItemToInventoryStackTooBig r4 16  // skip if stack too big
                add r3 r3 r5
                str r1 r3  // store new, bigger stack
                ret  // done
            .bank2_addItemToInventoryStackTooBig
            or r2 r2 15
            str r1 r2  // store max size stack
            sub r5 r5 15  // remaining items
            add r7 r6 r5  // new item id
        .bank2_addItemToInventoryLoopContinue
        sub r1 r1 inventory
        add r1 r1 1  // continue and check if done
    brl .bank2_addItemToInventoryLoop r1 15
ret






// try crafting - same subroutine for both 2x2 and 3x3 grids
.bank2_tryCrafting
    imm r1 15  // push entire inventory to stack - in case of not enough materials
    imm r2 inventory
    .bank2_tryCraftingToStackLoop
        lod r3 r2
        psh r3
        add r2 r2 1
        sub r1 r1 1
        bnz .bank2_tryCraftingToStackLoop r1

    imm r1 0  // index in crafting grid
    .bank2_tryCraftingMainLoop
        add r2 r1 craftingGrid  // get item id
        lod r2 r2
        and r2 r2 0xF0
        brz .bank2_tryCraftingLoopContinue r2  // continue if no item in that slot
        imm r3 0  // index in inventory
        .bank2_tryCraftingSubLoop
            add r4 r3 inventory  // get inventory item id
            lod r4 r4
            and r5 r4 0xF0  // check if same item id
            bre .bank2_tryCraftingLoopItemMatch r2 r5  // match!
            add r3 r3 1  // no match - continue
            brl .bank2_tryCraftingSubLoop r3 15  // if more inventory left, continue
        jmp .bank2_tryCraftingFailure  // no items of this id remain in inventory

        .bank2_tryCraftingLoopItemMatch
        sub r4 r4 1  // subtract 1 from item count
        and r5 r4 0x0F  // check if no items left in stack
        bnz ~+2 r5
            imm r4 0  // reset stack if no items left
        add r3 r3 inventory  // store item back
        str r3 r4
        .bank2_tryCraftingLoopContinue
        add r1 r1 1  // move along to next slot in crafting grid
        brl .bank2_tryCraftingMainLoop r1 9  // continue if not done all slots

    // success
        lod r7 craftingOutput  // add crafting output to inventory
        cal .bank2_addItemToInventory

        imm r1 15  // pop the (garbage) inventory off the stack
        .bank2_tryCraftingClearStackLoop
            pop r0
            sub r1 r1 1
            bnz .bank2_tryCraftingClearStackLoop r1

        str permanentSelectedSlot 0xFF  // reset permanent selected slot if successful
        cal .bank2_drawInventoryOnlyInventoryPart  // redraw inventory
    ret

    // failure
    .bank2_tryCraftingFailure
        imm r2 inventory  // pop entire inventory from stack
        add r2 r2 14
        .bank2_tryCraftingFromStackLoop
            pop r3
            str r2 r3
            sub r2 r2 1
            bge .bank2_tryCraftingFromStackLoop r2 inventory
        ret




// PLAYER INVENTORY (2x2 crafting grid)



// draw slot with highlight
.bank2_inventoryDrawSlotWithHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_drawHighlight
        ret
    // outside the crafting grid
    imm r4 0  // selected item
    cal .bank2_drawItem
ret

// draw slot without highlight (also clears highlight)
.bank2_inventoryDrawSlotWithoutHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_clearHighlight
        ret
    // outside the crafting grid
    imm r4 1  // not selected item
    cal .bank2_drawItem
ret

// reset crafting grid
.bank2_reset2x2CraftingGrid
    imm r1, craftingGrid  // memory address
    .bank2_reset2x2CraftingGridLoop  // can use loop counter on chungus
        str r1 0  // store empty item
        inc r1 r1
        ble .bank2_reset2x2CraftingGridLoop r1 craftingOutput  // loop if not done

    // draw background of grid
    out %screen_x1 26
    out %screen_y1 9
    out %screen_x2 44
    out %screen_y2_clearrect 27

    // draw items in grid
    imm r7 craftingGrid  // memory address
    imm r2 9  // y

    imm r1 26  // x
    imm r5 2  // length
    mov r6 r7  // memory address
    cal .bank2_drawGUIRowInGrid

    imm r2 18  // y
    imm r1 26  // x
    imm r5 2  // length
    add r6 r7 3  // memory address
    cal .bank2_drawGUIRowInGrid

    // draw output item
    imm r1 60  // x
    imm r2 14  // y
    imm r3 0  // no item
    imm r4 1  // not highlighted
    cal .bank2_drawItem
ret


// load GUI for open inventory
.bank2_loadInventoryGUI
    // draw inventory part and outline
    cal .bank2_drawInventory

    // draw crafting grid and output item
    cal .bank2_reset2x2CraftingGrid

    // draw "INVENTORY"
    out %screen_y1 1  // y
    out %screen_x1 40  // IN
    out %screen_texid_drawinvtex 0x70
    out %screen_x1 48  // VE
    out %screen_texid_drawinvtex 0x71
    out %screen_x1 56  // NT
    out %screen_texid_drawinvtex 0x72
    out %screen_x1 64  // OR
    out %screen_texid_drawinvtex 0x73
    out %screen_x1 72  // Y
    out %screen_texid_drawinvtex 0x74
    in r0 %screen_nop  // wait for screen queue to clear

    // draw arrow
    out %screen_x1 46  // x
    out %screen_y1 15  // y
    imm r1 TEXTURE_GUI_ARROW
    out %screen_texid_drawinvtex r1
    out %screen_x1 54  // new x
    add r1 r1 1
    out %screen_texid_drawinvtex r1

    // render and wait for inputs
    in r0 %screen_buffer

.bank2_inventoryLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        in r1 %playerinput //is open/close inventory pressed?
        bnz .continueFromClosingInventory r1
        
    // handle inventory movement
        in r1 %playerinput  // inventory movement
        lod r2 inventorySlot
        brz .bank2_inventorySkipMovement r1  // skip if no movement

        lod r7 inventorySlot
        psh r1
        cal .bank2_inventoryDrawSlotWithoutHighlight  // remove highlight from previous slot
        pop r1

        lod r2 inventorySlot
        brl .bank2_inventoryMoveWithinInventory r2 0x30

            // moving within crafting grid
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x60  // top of crafting grid
                    imm r2 0x00  // move to bottom of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x60  // bottom of crafting grid
                    imm r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+3 r1 0x0F  // move left
                sub r2 r2 1
                and r2 r2 0xF1  // stay within grid
            bne ~+3 r1 0x01  // move right
                add r2 r2 1
                and r2 r2 0xF1  // stay within grid

            jmp .bank2_inventorySkipMovement

        .bank2_inventoryMoveWithinInventory

            // moving within inventory
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x20  // top of inventory
                    imm r2 0x50  // move to crafting grid
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x10  // bottom of inventory
                    add r2 r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of inventory
                    add r2 r2 0x04  // move to right of inventory
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x04  // right of inventory
                    sub r2 r2 0x04  // move to left of inventory
                    jmp ~+2
                add r2 r2 1

        .bank2_inventorySkipMovement
            str inventorySlot r2  // draw selected slot
            mov r7 r2
            cal .bank2_inventoryDrawSlotWithHighlight

            in r1 %playerinput  // craft?
            brz .bank2_inventorySkipTryCrafting r1  // skip if not necessary
            lod r1 craftingOutput
            brz .bank2_inventorySkipTryCrafting r1  // skip if no crafting output

            cal .bank2_tryCrafting  // try and craft
            lod r7 inventorySlot  // redraw inventory slot (incase modified)
            cal .bank2_inventoryDrawSlotWithHighlight

        .bank2_inventorySkipTryCrafting
            lod r7 permanentSelectedSlot  // highlight permanent selected slot (if any)
            cal .bank2_inventoryDrawSlotWithHighlight

            in r1 %playerinput  // select item?
            brz .bank2_inventorySkipSelectItem r1  // skip if not necessary

            lod r1 permanentSelectedSlot  // get current permanent slot
            lod r2 inventorySlot
            bne .bank2_inventorySelectedAlready r1 0xFF  // already selected
                // select new slot
                bge .bank2_inventorySkipSelectItem r2 0x50  // out of bounds - do not select
                str permanentSelectedSlot r2  // set new permanent slot
                // NOTE: slot already highlighted (in previous section)
                jmp .bank2_inventorySkipSelectItem
            
            .bank2_inventorySelectedAlready
            // slot already selected
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            lod r3 r7
            mov r7 r2  // get memory address of new slot
            cal .bank2_inventoryGetSlot
            lod r4 r7
            str r7 r3  // move item(s) over
            psh r4  // preserve items
            mov r7 r2
            cal .bank2_inventoryDrawSlotWithHighlight
            pop r4
            lod r1 permanentSelectedSlot
            lod r2 inventorySlot
            bge .bank2_inventoryCheckCrafting r2 0x50  // out of bounds - only move

                // within bounds
                mov r7 r1  // get memory address of old slot
                cal .bank2_inventoryGetSlot
                str r7 r4  // swap items the other way
                mov r7 r1  // redraw and remove highlight
                cal .bank2_inventoryDrawSlotWithoutHighlight
                str permanentSelectedSlot 0xFF  // remove permanent selected slot
                lod r7 inventorySlot  // redraw slot if needed
                cal .bank2_inventoryDrawSlotWithHighlight
                jmp .bank2_inventorySkipSelectItem
        
        .bank2_inventoryCheckCrafting
            // check if a crafting recipe has been made possible
            out %craftrom 0xFF  // set to crafting mode
            imm r1 9  // output full crafting grid
            imm r2 craftingGrid
            .bank2_inventoryCheckCraftingLoop
                lod r3 r2
                out %craftrom r3
                add r2 r2 1
                sub r1 r1 1
                bnz .bank2_inventoryCheckCraftingLoop r1
            in r3 %craftrom  // get item (if any)
            str craftingOutput r3  // store
            // draw output item
            imm r1 60  // x
            imm r2 14  // y
            imm r4 1  // not highlighted
            cal .bank2_drawItem

        .bank2_inventorySkipSelectItem

            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage

            in r1 %playerinput  // clear crafting grid?
            brz .bank2_inventoryContinue r1
                cal .bank2_reset2x2CraftingGrid
                lod r7 inventorySlot  // redraw inventory slot
                cal .bank2_inventoryDrawSlotWithHighlight

    .bank2_inventoryContinue
    // render and wait for inputs
    in r0 %screen_buffer
    jmp .bank2_inventoryLoop




// CRAFTING INVENTORY (3x3 crafting grid)




// draw slot with highlight
.bank2_craftingDrawSlotWithHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_drawHighlight
        ret
    // outside the crafting grid
    imm r4 0  // selected item
    cal .bank2_drawItem
ret

// draw slot without highlight (also clears highlight)
.bank2_craftingDrawSlotWithoutHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_clearHighlight
        ret
    // outside the crafting grid
    imm r4 1  // not selected item
    cal .bank2_drawItem
ret

// reset crafting grid
.bank2_reset3x3CraftingGrid
    imm r1, craftingGrid  // memory address
    .bank2_reset3x3CraftingGridLoop  // can use loop counter on chungus
        str r1 0  // store empty item
        inc r1 r1
        ble .bank2_reset3x3CraftingGridLoop r1 craftingOutput  // loop if not done

    // draw background of grid
    out %screen_x1 21
    out %screen_y1 1
    out %screen_x2 48
    out %screen_y2_clearrect 28

    // draw items in grid
    imm r7 craftingGrid  // memory address
    imm r2 1  // y

    imm r1 21  // x
    imm r5 3  // length
    mov r6 r7  // memory address
    cal .bank2_drawGUIRowInGrid

    imm r2 10  // y
    imm r1 21  // x
    imm r5 3  // length
    add r6 r7 3  // memory address
    cal .bank2_drawGUIRowInGrid

    imm r2 19  // y
    imm r1 21  // x
    imm r5 3  // length
    add r6 r7 6  // memory address
    cal .bank2_drawGUIRowInGrid

    // draw output item
    imm r1 65  // x
    imm r2 10  // y
    imm r3 0  // no item
    imm r4 1  // not highlighted
    cal .bank2_drawItem
ret


// load GUI for open crafting grid
.bank2_loadCraftingGUI
    // draw inventory part and outline
    cal .bank2_drawInventory

    // draw crafting grid and output item
    cal .bank2_reset3x3CraftingGrid

    // draw "INVENTORY"
    out %screen_y1 1  // y
    out %screen_x1 56  // CR
    out %screen_texid_drawinvtex 0x75
    out %screen_x1 64  // AF
    out %screen_texid_drawinvtex 0x76
    out %screen_x1 72  // T
    out %screen_texid_drawinvtex 0x77
    in r0 %screen_nop  // wait for screen queue to clear

    // draw arrow
    out %screen_x1 51  // x
    out %screen_y1 11  // y
    imm r1 TEXTURE_GUI_ARROW
    out %screen_texid_drawinvtex r1
    out %screen_x1 59  // new x
    add r1 r1 1
    out %screen_texid_drawinvtex r1

    // render and wait for inputs
    in r0 %screen_buffer

.bank2_craftingLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        in r1 %playerinput //is open/close inventory pressed?
        bnz .continueFromClosingInventory r1
        
    // handle inventory movement
        in r1 %playerinput  // inventory movement
        lod r2 inventorySlot
        brz .bank2_craftingSkipMovement r1  // skip if no movement

        lod r7 inventorySlot
        psh r1
        cal .bank2_craftingDrawSlotWithoutHighlight  // remove highlight from previous slot
        pop r1

        lod r2 inventorySlot
        brl .bank2_craftingMoveWithinInventory r2 0x30

            // moving within crafting grid
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x90  // top of crafting grid
                    imm r2 0x00  // move to bottom of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x80  // bottom of crafting grid
                    imm r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of crafting grid
                    add r2 r2 0x02  // move to right of crafting grid
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x02  // right of crafting grid
                    sub r2 r2 0x02  // move to left of crafting grid
                    jmp ~+2
                add r2 r2 1

            jmp .bank2_craftingSkipMovement

        .bank2_craftingMoveWithinInventory

            // moving within inventory
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x20  // top of inventory
                    imm r2 0x70  // move to crafting grid
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x10  // bottom of inventory
                    add r2 r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of inventory
                    add r2 r2 0x04  // move to right of inventory
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x04  // right of inventory
                    sub r2 r2 0x04  // move to left of inventory
                    jmp ~+2
                add r2 r2 1

        .bank2_craftingSkipMovement
            str inventorySlot r2  // draw selected slot
            mov r7 r2
            cal .bank2_craftingDrawSlotWithHighlight

            in r1 %playerinput  // craft?
            brz .bank2_craftingSkipTryCrafting r1  // skip if not necessary
            lod r1 craftingOutput
            brz .bank2_craftingSkipTryCrafting r1  // skip if no crafting output

            cal .bank2_tryCrafting  // try and craft
            lod r7 inventorySlot  // redraw inventory slot (incase modified)
            cal .bank2_craftingDrawSlotWithHighlight

        .bank2_craftingSkipTryCrafting
            lod r7 permanentSelectedSlot  // highlight permanent selected slot (if any)
            cal .bank2_craftingDrawSlotWithHighlight

            in r1 %playerinput  // select item?
            brz .bank2_craftingSkipSelectItem r1  // skip if not necessary

            lod r1 permanentSelectedSlot  // get current permanent slot
            lod r2 inventorySlot
            bne .bank2_craftingSelectedAlready r1 0xFF  // already selected
                // select new slot
                bge .bank2_craftingSkipSelectItem r2 0x70  // out of bounds - do not select
                str permanentSelectedSlot r2  // set new permanent slot
                // NOTE: slot already highlighted (in previous section)
                jmp .bank2_craftingSkipSelectItem
            
            .bank2_craftingSelectedAlready
            // slot already selected
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            lod r3 r7
            mov r7 r2  // get memory address of new slot
            cal .bank2_inventoryGetSlot
            lod r4 r7
            str r7 r3  // move item(s) over
            psh r4  // preserve items
            mov r7 r2
            cal .bank2_craftingDrawSlotWithHighlight
            pop r4
            lod r1 permanentSelectedSlot
            lod r2 inventorySlot
            bge .bank2_craftingCheckCrafting r2 0x70  // out of bounds - only move

                // within bounds
                mov r7 r1  // get memory address of old slot
                cal .bank2_inventoryGetSlot
                str r7 r4  // swap items the other way
                mov r7 r1  // redraw and remove highlight
                cal .bank2_craftingDrawSlotWithoutHighlight
                str permanentSelectedSlot 0xFF  // remove permanent selected slot
                lod r7 inventorySlot  // redraw slot if needed
                cal .bank2_craftingDrawSlotWithHighlight
                jmp .bank2_craftingSkipSelectItem
        
        .bank2_craftingCheckCrafting
            // check if a crafting recipe has been made possible
            out %craftrom 0xFF  // set to crafting mode
            imm r1 9  // output full crafting grid
            imm r2 craftingGrid
            .bank2_craftingCheckCraftingLoop
                lod r3 r2
                out %craftrom r3
                add r2 r2 1
                sub r1 r1 1
                bnz .bank2_craftingCheckCraftingLoop r1
            in r3 %craftrom  // get item (if any)
            str craftingOutput r3  // store
            // draw output item
            imm r1 65  // x
            imm r2 10  // y
            imm r4 1  // not highlighted
            cal .bank2_drawItem

        .bank2_craftingSkipSelectItem

            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage

            in r1 %playerinput  // clear crafting grid?
            brz .bank2_craftingContinue r1
                cal .bank2_reset3x3CraftingGrid
                lod r7 inventorySlot  // redraw inventory slot
                cal .bank2_craftingDrawSlotWithHighlight

    .bank2_craftingContinue
    // render and wait for inputs
    in r0 %screen_buffer
    jmp .bank2_craftingLoop



//TODO: FURNACE GUI




//TODO: CHEST GUI